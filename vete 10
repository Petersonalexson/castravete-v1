let
    // Step 1: Reference the existing SmartViewData query
    SmartViewData = SmartViewData,
    
    // Step 2: Reference the XRP Tree and List arrays and Mapping Matrix
    XRPTreeArray = Excel.CurrentWorkbook(){[Name="XRP_Tree_Array"]}[Content],
    XRPListArray = Excel.CurrentWorkbook(){[Name="XRP_List_Array"]}[Content],
    MappingMatrix = Excel.CurrentWorkbook(){[Name="Mapping_Matrix"]}[Content],
    
    // Step 3: Prepare the XRP data first without filtering
    // Process Tree data - Convert first row to headers
    XRPTreeWithHeaders = Table.PromoteHeaders(XRPTreeArray, [PromoteAllScalars=true]),
    
    // Create a structured Tree table with proper column names
    XRPTreeClean = Table.SelectColumns(XRPTreeWithHeaders, {"Dimension_Name", "Value", "Parent", "V_S_C"}),
    
    // Rename and add type-specific columns
    XRPTreeTable = Table.RenameColumns(XRPTreeClean, {{"Dimension_Name", "Hierarchy Name"}}),
    XRPTreeWithType = Table.AddColumn(XRPTreeTable, "Type", each "Tree", type text),
    
    // Add KEY column to Tree data - with explicit text conversion
    XRPTreeWithKey = Table.AddColumn(XRPTreeWithType, "KEY", each Text.From([Hierarchy Name]) & " | " & Text.From([Value]), type text),
    
    // Process List data - Convert first row to headers
    XRPListWithHeaders = Table.PromoteHeaders(XRPListArray, [PromoteAllScalars=true]),
    
    // Create a structured List table
    XRPListClean = Table.SelectColumns(XRPListWithHeaders, {"Value", "V_S_C"}),
    
    // For List data, create Hierarchy Name from V_S_C and add empty Parent
    XRPListWithHierarchy = Table.AddColumn(XRPListClean, "Hierarchy Name", each [V_S_C], type text),
    XRPListWithParent = Table.AddColumn(XRPListWithHierarchy, "Parent", each "", type text),
    XRPListWithType = Table.AddColumn(XRPListWithParent, "Type", each "List", type text),
    
    // Add KEY column to List data - with explicit text conversion
    XRPListWithKey = Table.AddColumn(XRPListWithType, "KEY", each Text.From([Hierarchy Name]) & " | " & Text.From([Value]), type text),
    
    // Combine both XRP data sources
    CombinedXRP = Table.Combine({XRPTreeWithKey, XRPListWithKey}),
    
    // Step 4: Now process the Mapping Matrix to get valid combinations
    // Convert first row to headers
    MappingWithHeaders = try Table.PromoteHeaders(MappingMatrix) otherwise MappingMatrix,
    
    // Process Mapping Matrix only if it exists and not empty
    ValidMappingTable = if Table.RowCount(MappingWithHeaders) > 0 then MappingWithHeaders else null,
    
    // Apply filtering only if we have a valid Mapping Matrix
    FilteredXRP = if ValidMappingTable <> null and 
                     Table.HasColumns(ValidMappingTable, {"V_S_C"}) and 
                     Table.HasColumns(ValidMappingTable, {"Hierarchy Name"}) 
                  then
                     // Get the combination of V_S_C and Hierarchy Name from Mapping Matrix
                     let
                         VSC_HN_Map = Table.SelectColumns(ValidMappingTable, {"V_S_C", "Hierarchy Name"}),
                         // Filter XRP to keep only combinations present in the mapping
                         FilteredData = Table.NestedJoin(
                             CombinedXRP,
                             {"V_S_C", "Hierarchy Name"},
                             VSC_HN_Map,
                             {"V_S_C", "Hierarchy Name"},
                             "MappingMatch",
                             JoinKind.Inner
                         ),
                         CleanedData = Table.RemoveColumns(FilteredData, {"MappingMatch"})
                     in
                         CleanedData
                  else
                     // If no valid Mapping Matrix, use all XRP data
                     CombinedXRP,
    
    // Step 5: Ensure SmartView data also has KEY column with proper text conversion
    SmartViewWithKey = if Table.HasColumns(SmartViewData, "KEY") then
                          SmartViewData
                       else
                          Table.AddColumn(SmartViewData, "KEY", each Text.From([Hierarchy Name]) & " | " & Text.From([Value]), type text),
    
    // Step 6: Apply the same filtering to SmartView data if valid Mapping Matrix exists
    FilteredSmartView = if ValidMappingTable <> null and 
                          Table.HasColumns(ValidMappingTable, {"V_S_C"}) and 
                          Table.HasColumns(ValidMappingTable, {"Hierarchy Name"}) 
                       then
                          // Get the combination of V_S_C and Hierarchy Name from Mapping Matrix
                          let
                              VSC_HN_Map = Table.SelectColumns(ValidMappingTable, {"V_S_C", "Hierarchy Name"}),
                              // Filter SmartView to keep only combinations present in the mapping
                              FilteredData = Table.NestedJoin(
                                  SmartViewWithKey,
                                  {"V_S_C", "Hierarchy Name"},
                                  VSC_HN_Map,
                                  {"V_S_C", "Hierarchy Name"},
                                  "MappingMatch",
                                  JoinKind.Inner
                              ),
                              CleanedData = Table.RemoveColumns(FilteredData, {"MappingMatch"})
                          in
                              CleanedData
                       else
                          // If no valid Mapping Matrix, use all SmartView data
                          SmartViewWithKey,
    
    // Step 7: Separate data by Type
    SVTree = Table.SelectRows(FilteredSmartView, each [Type] = "Tree"),
    SVList = Table.SelectRows(FilteredSmartView, each [Type] = "List"),
    XRPTree = Table.SelectRows(FilteredXRP, each [Type] = "Tree"),
    XRPList = Table.SelectRows(FilteredXRP, each [Type] = "List"),
    
    // Step 8: Join Tree data using both V_S_C and KEY
    SVTreeJoin = Table.NestedJoin(
        SVTree,
        {"V_S_C", "KEY"},
        XRPTree,
        {"V_S_C", "KEY"},
        "XRPMatches",
        JoinKind.LeftOuter
    ),
    
    // Use full record expansion to prevent parent issues
    SVTreeWithXRP = Table.ExpandTableColumn(
        SVTreeJoin,
        "XRPMatches",
        {"Parent"},
        {"XRP_Parent"}
    ),
    
    // Step 9: Join List data using both V_S_C and KEY
    SVListJoin = Table.NestedJoin(
        SVList,
        {"V_S_C", "KEY"},
        XRPList,
        {"V_S_C", "KEY"},
        "XRPMatches",
        JoinKind.LeftOuter
    ),
    
    // Use full record expansion to prevent parent issues
    SVListWithXRP = Table.ExpandTableColumn(
        SVListJoin,
        "XRPMatches",
        {"Parent"},
        {"XRP_Parent"}
    ),
    
    // Step 10: Combine joined SmartView results
    CombinedSVWithXRP = Table.Combine({SVTreeWithXRP, SVListWithXRP}),
    
    // Step 11: Find XRP items not in SmartView (anti-join)
    XRPTreeAnti = Table.NestedJoin(
        XRPTree,
        {"V_S_C", "KEY"},
        SVTree,
        {"V_S_C", "KEY"},
        "SVMatches",
        JoinKind.LeftAnti
    ),
    
    XRPTreeAntiCleaned = Table.RemoveColumns(XRPTreeAnti, {"SVMatches"}),
    
    XRPListAnti = Table.NestedJoin(
        XRPList,
        {"V_S_C", "KEY"},
        SVList,
        {"V_S_C", "KEY"},
        "SVMatches",
        JoinKind.LeftAnti
    ),
    
    XRPListAntiCleaned = Table.RemoveColumns(XRPListAnti, {"SVMatches"}),
    
    // Step 12: Combine XRP-only items
    CombinedXRPOnly = Table.Combine({XRPTreeAntiCleaned, XRPListAntiCleaned}),
    
    // Make sure Parent column is preserved - rename to be consistent
    CombinedXRPOnlyWithRenamedParent = Table.RenameColumns(CombinedXRPOnly, {{"Parent", "XRP_Parent"}}),
    
    // Step 13: Add placeholder SmartView columns to XRP-only data
    XRPOnlyWithSVValue = Table.AddColumn(CombinedXRPOnlyWithRenamedParent, "SV_Value", each null, type text),
    XRPOnlyWithSVParent = Table.AddColumn(XRPOnlyWithSVValue, "SV_Parent", each null, type text),
    
    // Step 14: Rename columns for consistency in the SmartView data
    SVWithXRPRenamed = Table.RenameColumns(CombinedSVWithXRP, {
        {"Value", "SV_Value"},
        {"Parent", "SV_Parent"}
    }),
    
    // Step 15: Combine all results
    AllResults = Table.Combine({SVWithXRPRenamed, XRPOnlyWithSVParent}),
    
    // Step 16: Add Status column
    WithStatus = Table.AddColumn(AllResults, "Status", each
        if [SV_Value] = null then "Missing in SmartView"
        else if [XRP_Parent] = null then "Missing in XRP"
        else if [Type] = "Tree" and [SV_Parent] <> [XRP_Parent] then "Different Parent"
        else "Match",
        type text
    ),
    
    // Step 17: Select and rename final columns
    FinalColumns = Table.SelectColumns(WithStatus, {
        "Type", "V_S_C", "Hierarchy Name", "SV_Value", "SV_Parent", "XRP_Parent", "Status"
    }),
    
    FinalRenamed = Table.RenameColumns(FinalColumns, {
        {"SV_Value", "Value"},
        {"SV_Parent", "SmartView Parent"},
        {"XRP_Parent", "XRP Parent"}
    }),
    
    // Step 18: Sort results
    SortedResults = Table.Sort(FinalRenamed, {
        {"Type", Order.Ascending},
        {"V_S_C", Order.Ascending},
        {"Hierarchy Name", Order.Ascending},
        {"Status", Order.Ascending}
    })
in
    SortedResults
