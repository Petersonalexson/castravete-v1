Option Explicit

' Procedure to write to process log
Private Sub WriteProcessLog(ByRef wsProcessLog As Worksheet, ByVal Msg As String)
    Dim nextLogRow As Long
    nextLogRow = wsProcessLog.Cells(wsProcessLog.Rows.Count, "A").End(xlUp).Row + 1
    wsProcessLog.Cells(nextLogRow, 1).Value = Now
    wsProcessLog.Cells(nextLogRow, 2).Value = Msg
End Sub

Sub PopulateFuture_5Blocks_WithProcessLog()
    Dim wb As Workbook: Set wb = ThisWorkbook
    Dim wsGenerate As Worksheet: Set wsGenerate = wb.Sheets("Generate")
    Dim wsAcctMap As Worksheet:  Set wsAcctMap = wb.Sheets("Account Mapping")
    Dim wsFuture As Worksheet:   Set wsFuture = wb.Sheets("FUTURE")
    Dim wsProcessLog As Worksheet: Set wsProcessLog = wb.Sheets("ProcessLog")
    
    Dim SubName As String
    SubName = "PopulateFuture_5Blocks_WithProcessLog"
    
    Call WriteProcessLog(wsProcessLog, SubName & ": Started macro.")
    
    ' Clear existing data in FUTURE sheet cells that might be populated
    Call WriteProcessLog(wsProcessLog, "Clearing existing data in target FUTURE cells...")
    Dim cornerCells As Variant
    cornerCells = Array("C6", "C22", "C38", "C54", "C70")
    Dim idx As Long
    For idx = LBound(cornerCells) To UBound(cornerCells)
        Dim cellRef As String
        cellRef = cornerCells(idx)
        Dim rngCorner As Range
        Set rngCorner = wsFuture.Range(cellRef)
        
        If Not IsEmpty(rngCorner.Value) Then
            ' Find the range to clear
            Dim startRow As Long, startCol As Long
            Dim endRow As Long, endCol As Long
            startRow = rngCorner.Row + 1
            startCol = rngCorner.Column + 1
            
            ' Find endRow
            endRow = startRow
            Do While Not IsEmpty(wsFuture.Cells(endRow, rngCorner.Column).Value)
                endRow = endRow + 1
            Loop
            endRow = endRow - 1
            
            ' Find endCol
            endCol = startCol
            Do While Not IsEmpty(wsFuture.Cells(rngCorner.Row, endCol).Value)
                endCol = endCol + 1
            Loop
            endCol = endCol - 1
            
            ' Clear data area (but not headers)
            If endRow >= startRow And endCol >= startCol Then
                wsFuture.Range(wsFuture.Cells(startRow, startCol), wsFuture.Cells(endRow, endCol)).ClearContents
                Call WriteProcessLog(wsProcessLog, "Cleared data for CC block at " & cellRef)
            End If
        End If
    Next idx
    
    ' Get XAV sheet name from Generate sheet
    Dim XAVSheetName As String
    XAVSheetName = CStr(wsGenerate.Range("D7").Value)
    
    ' Locate XAV sheet
    Dim wsXAV As Worksheet
    On Error Resume Next
    Set wsXAV = wb.Sheets(XAVSheetName)
    On Error GoTo 0
    
    If wsXAV Is Nothing Then
        Call WriteProcessLog(wsProcessLog, "ERROR: Cannot find XAV sheet named '" & XAVSheetName & "'.")
        MsgBox "Cannot find XAV sheet named '" & XAVSheetName & "'. Check Generate!D7!", vbExclamation
        Exit Sub
    Else
        Call WriteProcessLog(wsProcessLog, "Found XAV sheet: " & XAVSheetName)
    End If
    
    ' Validate XAV sheet columns
    If wsXAV.Range("A1").Value <> "Fiscal Period" Or _
       wsXAV.Range("E1").Value <> "CC" Or _
       wsXAV.Range("C1").Value <> "Account" Or _
       wsXAV.Range("N1").Value <> "voice num" Or _
       wsXAV.Range("O1").Value <> "amount" Then
        Call WriteProcessLog(wsProcessLog, "ERROR: XAV sheet headers don't match expected format.")
        MsgBox "XAV sheet headers don't match expected format. Check if headers are: Fiscal Period(A1), CC(E1), Account(C1), voice num(N1), amount(O1)", vbExclamation
        Exit Sub
    End If
    
    ' Validate Account Mapping sheet columns
    If wsAcctMap.Range("B1").Value <> "Account" Or _
       wsAcctMap.Range("D1").Value <> "Description 2" Then
        Call WriteProcessLog(wsProcessLog, "ERROR: Account Mapping sheet headers don't match expected format.")
        MsgBox "Account Mapping sheet headers don't match expected format. Check if headers are: Account(B1), Description 2(D1)", vbExclamation
        Exit Sub
    End If
    
    ' Read Account Mapping (NAT Account --> Report Description)
    Call WriteProcessLog(wsProcessLog, "Reading 'Account Mapping' for Account --> Report Description...")
    
    Dim dictAccountMap As Object
    Set dictAccountMap = CreateObject("Scripting.Dictionary")
    dictAccountMap.CompareMode = vbTextCompare
    
    Dim lastRowAcct As Long
    With wsAcctMap
        lastRowAcct = .Cells(.Rows.Count, "B").End(xlUp).Row
        Dim i As Long
        For i = 2 To lastRowAcct
            Dim acctVal As Variant
            Dim reportDescVal As Variant
            acctVal = .Range("B" & i).Value
            reportDescVal = .Range("D" & i).Value
            If Not IsEmpty(acctVal) And Not IsEmpty(reportDescVal) Then
                If Not dictAccountMap.Exists(acctVal) Then
                    dictAccountMap.Add acctVal, reportDescVal
                End If
            End If
        Next i
    End With
    
    Call WriteProcessLog(wsProcessLog, "Account Mapping loaded. Total mappings: " & dictAccountMap.Count)
    
    ' Read reference mapping for XAV period to FUTURE column
    Call WriteProcessLog(wsProcessLog, "Reading period reference mapping...")
    
    Dim dictPeriodMap As Object
    Set dictPeriodMap = CreateObject("Scripting.Dictionary")
    dictPeriodMap.CompareMode = vbTextCompare
    
    Dim lastRowPeriodMap As Long
    lastRowPeriodMap = wsAcctMap.Cells(wsAcctMap.Rows.Count, "F").End(xlUp).Row
    
    For i = 2 To lastRowPeriodMap
        If Not IsEmpty(wsAcctMap.Range("F" & i).Value) And Not IsEmpty(wsAcctMap.Range("C" & i).Value) Then
            Dim xavPeriod As Variant
            Dim futureCol As Variant
            xavPeriod = wsAcctMap.Range("F" & i).Value
            futureCol = wsAcctMap.Range("C" & i).Value
            If Not dictPeriodMap.Exists(xavPeriod) Then
                dictPeriodMap.Add xavPeriod, futureCol
            End If
        End If
    Next i
    
    Call WriteProcessLog(wsProcessLog, "Period mapping loaded. Total mappings: " & dictPeriodMap.Count)
    
    ' Read description mapping (Description 2 to FUTURE Description)
    Call WriteProcessLog(wsProcessLog, "Reading description mapping...")
    
    Dim dictDescMap As Object
    Set dictDescMap = CreateObject("Scripting.Dictionary")
    dictDescMap.CompareMode = vbTextCompare
    
    Dim lastRowDescMap As Long
    lastRowDescMap = wsAcctMap.Cells(wsAcctMap.Rows.Count, "B").End(xlUp).Row
    
    Dim startDescMapRow As Long
    startDescMapRow = 15  ' B15 as mentioned
    
    For i = startDescMapRow To lastRowDescMap
        If Not IsEmpty(wsAcctMap.Range("B" & i).Value) And Not IsEmpty(wsAcctMap.Range("C" & i).Value) Then
            Dim desc2Val As Variant
            Dim futureDesc As Variant
            desc2Val = wsAcctMap.Range("B" & i).Value
            futureDesc = wsAcctMap.Range("C" & i).Value
            If Not dictDescMap.Exists(desc2Val) Then
                dictDescMap.Add desc2Val, futureDesc
            End If
        End If
    Next i
    
    Call WriteProcessLog(wsProcessLog, "Description mapping loaded. Total mappings: " & dictDescMap.Count)
    
    ' Create final mapping dictionary (Account to FUTURE Description)
    Dim dictFinalDescMap As Object
    Set dictFinalDescMap = CreateObject("Scripting.Dictionary")
    dictFinalDescMap.CompareMode = vbTextCompare
    
    Dim acctVal As Variant
    For Each acctVal In dictAccountMap.Keys
        Dim desc2 As Variant
        desc2 = dictAccountMap(acctVal)
        
        If dictDescMap.Exists(desc2) Then
            dictFinalDescMap.Add acctVal, dictDescMap(desc2)
        Else
            ' If no mapping exists in second map, use the original description
            dictFinalDescMap.Add acctVal, desc2
        End If
    Next
    
    Call WriteProcessLog(wsProcessLog, "Starting XAV summation with bonus logic...")
    
    Dim lastRowXAV As Long
    lastRowXAV = wsXAV.Cells(wsXAV.Rows.Count, "A").End(xlUp).Row
    
    Dim dictResults As Object
    Set dictResults = CreateObject("Scripting.Dictionary")
    dictResults.CompareMode = vbTextCompare
    
    Dim dictProcessed As Object
    Set dictProcessed = CreateObject("Scripting.Dictionary")
    dictProcessed.CompareMode = vbTextCompare
    
    ' Process XAV data
    Dim rowXAV As Long
    For rowXAV = 2 To lastRowXAV
        Dim voiceNum As Variant
        voiceNum = wsXAV.Range("N" & rowXAV).Value
        
        ' Skip if already processed this voice number
        If Not dictProcessed.Exists(voiceNum) Then
            dictProcessed.Add voiceNum, True
            
            ' Calculate sum for this voice number
            Dim bonusTotal As Double
            bonusTotal = 0
            Dim rowXAV2 As Long
            For rowXAV2 = 2 To lastRowXAV
                If wsXAV.Range("N" & rowXAV2).Value = voiceNum Then
                    Dim amountVal As Variant
                    amountVal = wsXAV.Range("O" & rowXAV2).Value
                    ' Ensure numeric value before adding
                    If IsNumeric(amountVal) Then
                        bonusTotal = bonusTotal + CDbl(amountVal)
                    End If
                End If
            Next rowXAV2
            
            Dim costCenter As Variant
            costCenter = wsXAV.Range("E" & rowXAV).Value
            
            Dim accountVal As Variant
            accountVal = wsXAV.Range("C" & rowXAV).Value
            
            Dim repDescVal As Variant
            If dictFinalDescMap.Exists(accountVal) Then
                repDescVal = dictFinalDescMap(accountVal)
            Else
                Call WriteProcessLog(wsProcessLog, "WARNING: Account '" & accountVal & "' not in mapping. VoiceNum=" & voiceNum)
                GoTo SkipVoiceNum
            End If
            
            Dim thisPeriod As Variant
            thisPeriod = wsXAV.Range("A" & rowXAV).Value
            
            ' Check if period exists in period mapping
            If Not dictPeriodMap.Exists(thisPeriod) Then
                Call WriteProcessLog(wsProcessLog, "WARNING: Period '" & thisPeriod & "' not in period mapping. VoiceNum=" & voiceNum)
                GoTo SkipVoiceNum
            End If
            
            Dim key As String
            key = CStr(costCenter) & "||" & CStr(repDescVal) & "||" & CStr(thisPeriod)
            
            If dictResults.Exists(key) Then
                dictResults(key) = dictResults(key) + bonusTotal
            Else
                dictResults.Add key, bonusTotal
            End If
            
            Call WriteProcessLog(wsProcessLog, "VoiceNum=" & voiceNum & " => CC=" & costCenter & ", Desc=" & repDescVal & ", Period=" & thisPeriod & ", Total=" & bonusTotal)
SkipVoiceNum:
        End If
    Next rowXAV
    
    Call WriteProcessLog(wsProcessLog, "Done summation. Total unique keys: " & dictResults.Count)
    
    Call WriteProcessLog(wsProcessLog, "Populating FUTURE in 5 blocks...")
    
    ' Process each corner cell (CC block)
    For idx = LBound(cornerCells) To UBound(cornerCells)
        cellRef = cornerCells(idx)
        Set rngCorner = wsFuture.Range(cellRef)
        Dim blockCC As Variant
        blockCC = rngCorner.Value
        
        If IsEmpty(blockCC) Then
            Call WriteProcessLog(wsProcessLog, "Block corner " & cellRef & " is empty, skipping.")
            GoTo NextCorner
        End If
        
        Call WriteProcessLog(wsProcessLog, "Processing block corner " & cellRef & " => CC=" & blockCC)
        
        ' Map periods to columns
        Dim dictPeriodToCol As Object
        Set dictPeriodToCol = CreateObject("Scripting.Dictionary")
        dictPeriodToCol.CompareMode = vbTextCompare
        
        Dim startCol As Long
        startCol = rngCorner.Column + 1
        Dim colPtr As Long
        colPtr = startCol
        
        Do While Not IsEmpty(wsFuture.Cells(rngCorner.Row, colPtr).Value)
            Dim periodVal As Variant
            periodVal = wsFuture.Cells(rngCorner.Row, colPtr).Value
            dictPeriodToCol(CStr(periodVal)) = colPtr
            colPtr = colPtr + 1
        Loop
        
        Call WriteProcessLog(wsProcessLog, "Found " & dictPeriodToCol.Count & " period(s) to the right of " & cellRef)
        
        ' Map descriptions to rows
        Dim dictDescToRow As Object
        Set dictDescToRow = CreateObject("Scripting.Dictionary")
        dictDescToRow.CompareMode = vbTextCompare
        
        Dim startRow As Long
        startRow = rngCorner.Row + 1
        Dim rowPtr As Long
        rowPtr = startRow
        
        Do While Not IsEmpty(wsFuture.Cells(rowPtr, rngCorner.Column).Value)
            Dim descVal As Variant
            descVal = wsFuture.Cells(rowPtr, rngCorner.Column).Value
            dictDescToRow(CStr(descVal)) = rowPtr
            rowPtr = rowPtr + 1
        Loop
        
        Call WriteProcessLog(wsProcessLog, "Found " & dictDescToRow.Count & " Report Description(s) below " & cellRef)
        
        ' Populate FUTURE cells from results dictionary
        Dim arrKeys As Variant
        arrKeys = dictResults.keys
        Dim k As Long
        For k = LBound(arrKeys) To UBound(arrKeys)
            Dim parts() As String
            parts = Split(arrKeys(k), "||")
            Dim ccKey As String
            ccKey = parts(0)
            
            ' Check if this entry belongs to current CC block
            If ccKey = CStr(blockCC) Then
                Dim repDescKey As String
                repDescKey = parts(1)
                Dim xavPeriodKey As String
                xavPeriodKey = parts(2)
                
                ' Get mapped period for FUTURE
                Dim futurePeriodKey As String
                If dictPeriodMap.Exists(xavPeriodKey) Then
                    futurePeriodKey = dictPeriodMap(xavPeriodKey)
                Else
                    Call WriteProcessLog(wsProcessLog, "WARNING: No period mapping for " & xavPeriodKey & " in CC=" & blockCC)
                    GoTo NextKey
                End If
                
                ' Check if we have a matching row and column
                If dictDescToRow.Exists(repDescKey) And dictPeriodToCol.Exists(futurePeriodKey) Then
                    Dim targetRow As Long
                    targetRow = dictDescToRow(repDescKey)
                    Dim targetCol As Long
                    targetCol = dictPeriodToCol(futurePeriodKey)
                    Dim totalVal As Double
                    totalVal = dictResults(arrKeys(k))
                    
                    ' Add to existing value if there's already a value
                    Dim existingVal As Variant
                    existingVal = wsFuture.Cells(targetRow, targetCol).Value
                    If IsNumeric(existingVal) Then
                        wsFuture.Cells(targetRow, targetCol).Value = CDbl(existingVal) + totalVal
                    Else
                        wsFuture.Cells(targetRow, targetCol).Value = totalVal
                    End If
                    
                    Call WriteProcessLog(wsProcessLog, "Wrote CC=" & blockCC & ", Desc=" & repDescKey & ", Period=" & futurePeriodKey & " => " & totalVal & " at R" & targetRow & "C" & targetCol)
                End If
NextKey:
            End If
        Next k
NextCorner:
    Next idx
    
    ' Calculate totals if needed
    Call WriteProcessLog(wsProcessLog, "Calculating row and column totals...")
    For idx = LBound(cornerCells) To UBound(cornerCells)
        cellRef = cornerCells(idx)
        Set rngCorner = wsFuture.Range(cellRef)
        blockCC = rngCorner.Value
        
        If IsEmpty(blockCC) Then
            GoTo NextCornerTotal
        End If
        
        startRow = rngCorner.Row + 1
        rowPtr = startRow
        startCol = rngCorner.Column + 1
        colPtr = startCol
        
        ' Find the boundaries
        Dim lastRow As Long, lastCol As Long
        lastRow = startRow
        Do While Not IsEmpty(wsFuture.Cells(lastRow, rngCorner.Column).Value)
            lastRow = lastRow + 1
        Loop
        lastRow = lastRow - 1
        
        lastCol = startCol
        Do While Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol).Value)
            lastCol = lastCol + 1
        Loop
        lastCol = lastCol - 1
        
        ' Add row totals
        For rowPtr = startRow To lastRow
            Dim rowTotal As Double
            rowTotal = 0
            
            For colPtr = startCol To lastCol
                Dim cellVal As Variant
                cellVal = wsFuture.Cells(rowPtr, colPtr).Value
                
                If IsNumeric(cellVal) Then
                    rowTotal = rowTotal + CDbl(cellVal)
                End If
            Next colPtr
            
            ' Write row total if there's a total column
            If Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol + 1).Value) Then
                wsFuture.Cells(rowPtr, lastCol + 1).Value = rowTotal
            End If
        Next rowPtr
        
        ' Add column totals
        For colPtr = startCol To lastCol
            Dim colTotal As Double
            colTotal = 0
            
            For rowPtr = startRow To lastRow
                cellVal = wsFuture.Cells(rowPtr, colPtr).Value
                
                If IsNumeric(cellVal) Then
                    colTotal = colTotal + CDbl(cellVal)
                End If
            Next rowPtr
            
            ' Write column total if there's a total row
            If Not IsEmpty(wsFuture.Cells(lastRow + 1, rngCorner.Column).Value) Then
                wsFuture.Cells(lastRow + 1, colPtr).Value = colTotal
            End If
        Next colPtr
        
        ' Grand total if both total row and column exist
        If Not IsEmpty(wsFuture.Cells(lastRow + 1, rngCorner.Column).Value) And _
           Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol + 1).Value) Then
            Dim grandTotal As Double
            grandTotal = 0
            
            For rowPtr = startRow To lastRow
                For colPtr = startCol To lastCol
                    cellVal = wsFuture.Cells(rowPtr, colPtr).Value
                    
                    If IsNumeric(cellVal) Then
                        grandTotal = grandTotal + CDbl(cellVal)
                    End If
                Next colPtr
            Next rowPtr
            
            wsFuture.Cells(lastRow + 1, lastCol + 1).Value = grandTotal
        End If
        
NextCornerTotal:
    Next idx
    
    Call WriteProcessLog(wsProcessLog, SubName & ": Completed successfully!")
    MsgBox "FUTURE sheet updated for all 5 CC blocks! See 'ProcessLog' for details.", vbInformation
End Sub
