Option Explicit

' Procedure to write to process log
Public Sub WriteProcessLog(ByRef wsProcessLog As Worksheet, ByVal Msg As String)
    Dim nextLogRow As Long
    nextLogRow = wsProcessLog.Cells(wsProcessLog.Rows.Count, "A").End(xlUp).Row + 1
    wsProcessLog.Cells(nextLogRow, 1).Value = Now
    wsProcessLog.Cells(nextLogRow, 2).Value = Msg
End Sub

Public Sub PopulateFuture_5Blocks_WithProcessLog()
    ' Main workbook and worksheets
    Dim wb As Workbook
    Set wb = ThisWorkbook
    
    Dim wsGenerate As Worksheet
    Dim wsAcctMap As Worksheet
    Dim wsFuture As Worksheet
    Dim wsProcessLog As Worksheet
    Dim wsXAV As Worksheet
    
    Set wsGenerate = wb.Sheets("Generate")
    Set wsAcctMap = wb.Sheets("Account Mapping")
    Set wsFuture = wb.Sheets("FUTURE")
    Set wsProcessLog = wb.Sheets("ProcessLog")
    
    ' Variables for storing data
    Dim SubName As String
    Dim XAVSheetName As String
    Dim cornerCells As Variant
    
    ' Loop counters
    Dim i As Long
    Dim k As Long
    Dim idx As Long
    Dim rowXAV As Long
    Dim rowXAV2 As Long
    Dim colPtr As Long
    Dim rowPtr As Long
    
    ' Row/Column positions
    Dim startRow As Long
    Dim startCol As Long
    Dim lastRow As Long
    Dim lastCol As Long
    Dim targetRow As Long
    Dim targetCol As Long
    Dim lastRowAcct As Long
    Dim lastRowXAV As Long
    Dim lastRowPeriodMap As Long
    Dim lastRowDescMap As Long
    Dim startDescMapRow As Long
    
    ' Cell values
    Dim cellRef As String
    Dim blockCC As Variant
    Dim voiceNum As Variant
    Dim costCenter As Variant
    Dim acctVal As Variant
    Dim reportDescVal As Variant
    Dim accountVal As Variant
    Dim amountVal As Variant
    Dim repDescVal As Variant
    Dim thisPeriod As Variant
    Dim xavPeriod As Variant
    Dim futureCol As Variant
    Dim desc2Val As Variant
    Dim futureDesc As Variant
    Dim periodVal As Variant
    Dim desc2 As Variant
    Dim descVal As Variant
    Dim existingVal As Variant
    Dim cellVal As Variant
    
    ' Calculation values
    Dim bonusTotal As Double
    Dim rowTotal As Double
    Dim colTotal As Double
    Dim grandTotal As Double
    Dim totalVal As Double
    
    ' Key variables
    Dim key As String
    Dim ccKey As String
    Dim repDescKey As String
    Dim xavPeriodKey As String
    Dim futurePeriodKey As String
    Dim parts() As String
    Dim arrKeys As Variant
    
    ' Dictionary objects
    Dim dictAccountMap As Object
    Dim dictPeriodMap As Object
    Dim dictDescMap As Object
    Dim dictFinalDescMap As Object
    Dim dictResults As Object
    Dim dictProcessed As Object
    Dim dictPeriodToCol As Object
    Dim dictDescToRow As Object
    Dim rngCorner As Range
    
    ' Start macro
    SubName = "PopulateFuture_5Blocks_WithProcessLog"
    Call WriteProcessLog(wsProcessLog, SubName & ": Started macro.")
    
    ' Clear existing data in FUTURE sheet cells that might be populated
    Call WriteProcessLog(wsProcessLog, "Clearing existing data in target FUTURE cells...")
    cornerCells = Array("C6", "C22", "C38", "C54", "C70")
    
    For idx = LBound(cornerCells) To UBound(cornerCells)
        cellRef = cornerCells(idx)
        Set rngCorner = wsFuture.Range(cellRef)
        
        If Not IsEmpty(rngCorner.Value) Then
            ' Find the range to clear
            startRow = rngCorner.Row + 1
            startCol = rngCorner.Column + 1
            
            ' Find endRow
            lastRow = startRow
            Do While Not IsEmpty(wsFuture.Cells(lastRow, rngCorner.Column).Value)
                lastRow = lastRow + 1
            Loop
            lastRow = lastRow - 1
            
            ' Find endCol
            lastCol = startCol
            Do While Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol).Value)
                lastCol = lastCol + 1
            Loop
            lastCol = lastCol - 1
            
            ' Clear data area (but not headers)
            If lastRow >= startRow And lastCol >= startCol Then
                wsFuture.Range(wsFuture.Cells(startRow, startCol), wsFuture.Cells(lastRow, lastCol)).ClearContents
                Call WriteProcessLog(wsProcessLog, "Cleared data for CC block at " & cellRef)
            End If
        End If
    Next idx
    
    ' Get XAV sheet name from Generate sheet
    XAVSheetName = CStr(wsGenerate.Range("D7").Value)
    
    ' Locate XAV sheet
    On Error Resume Next
    Set wsXAV = wb.Sheets(XAVSheetName)
    On Error GoTo 0
    
    If wsXAV Is Nothing Then
        Call WriteProcessLog(wsProcessLog, "ERROR: Cannot find XAV sheet named '" & XAVSheetName & "'.")
        MsgBox "Cannot find XAV sheet named '" & XAVSheetName & "'. Check Generate!D7!", vbExclamation
        Exit Sub
    Else
        Call WriteProcessLog(wsProcessLog, "Found XAV sheet: " & XAVSheetName)
    End If
    
    ' Validate XAV sheet columns
    If wsXAV.Range("A1").Value <> "Fiscal Period" Or _
       wsXAV.Range("E1").Value <> "CC" Or _
       wsXAV.Range("C1").Value <> "Account" Or _
       wsXAV.Range("N1").Value <> "voice num" Or _
       wsXAV.Range("O1").Value <> "amount" Then
        Call WriteProcessLog(wsProcessLog, "ERROR: XAV sheet headers don't match expected format.")
        MsgBox "XAV sheet headers don't match expected format. Check if headers are: Fiscal Period(A1), CC(E1), Account(C1), voice num(N1), amount(O1)", vbExclamation
        Exit Sub
    End If
    
    ' Validate Account Mapping sheet columns
    If wsAcctMap.Range("B1").Value <> "Account" Or _
       wsAcctMap.Range("D1").Value <> "Description 2" Then
        Call WriteProcessLog(wsProcessLog, "ERROR: Account Mapping sheet headers don't match expected format.")
        MsgBox "Account Mapping sheet headers don't match expected format. Check if headers are: Account(B1), Description 2(D1)", vbExclamation
        Exit Sub
    End If
    
    ' Read Account Mapping (NAT Account --> Report Description)
    Call WriteProcessLog(wsProcessLog, "Reading 'Account Mapping' for Account --> Report Description...")
    
    Set dictAccountMap = CreateObject("Scripting.Dictionary")
    dictAccountMap.CompareMode = vbTextCompare
    
    With wsAcctMap
        lastRowAcct = .Cells(.Rows.Count, "B").End(xlUp).Row
        For i = 2 To lastRowAcct
            acctVal = .Range("B" & i).Value
            reportDescVal = .Range("D" & i).Value
            If Not IsEmpty(acctVal) And Not IsEmpty(reportDescVal) Then
                If Not dictAccountMap.Exists(acctVal) Then
                    dictAccountMap.Add acctVal, reportDescVal
                End If
            End If
        Next i
    End With
    
    Call WriteProcessLog(wsProcessLog, "Account Mapping loaded. Total mappings: " & dictAccountMap.Count)
    
    ' Read reference mapping for XAV period to FUTURE column
    Call WriteProcessLog(wsProcessLog, "Reading period reference mapping...")
    
    Set dictPeriodMap = CreateObject("Scripting.Dictionary")
    dictPeriodMap.CompareMode = vbTextCompare
    
    lastRowPeriodMap = wsAcctMap.Cells(wsAcctMap.Rows.Count, "F").End(xlUp).Row
    
    For i = 2 To lastRowPeriodMap
        If Not IsEmpty(wsAcctMap.Range("F" & i).Value) And Not IsEmpty(wsAcctMap.Range("C" & i).Value) Then
            xavPeriod = wsAcctMap.Range("F" & i).Value
            futureCol = wsAcctMap.Range("C" & i).Value
            If Not dictPeriodMap.Exists(xavPeriod) Then
                dictPeriodMap.Add xavPeriod, futureCol
            End If
        End If
    Next i
    
    Call WriteProcessLog(wsProcessLog, "Period mapping loaded. Total mappings: " & dictPeriodMap.Count)
    
    ' Read description mapping (Description 2 to FUTURE Description)
    Call WriteProcessLog(wsProcessLog, "Reading description mapping...")
    
    Set dictDescMap = CreateObject("Scripting.Dictionary")
    dictDescMap.CompareMode = vbTextCompare
    
    lastRowDescMap = wsAcctMap.Cells(wsAcctMap.Rows.Count, "B").End(xlUp).Row
    
    startDescMapRow = 15  ' B15 as mentioned
    
    For i = startDescMapRow To lastRowDescMap
        If Not IsEmpty(wsAcctMap.Range("B" & i).Value) And Not IsEmpty(wsAcctMap.Range("C" & i).Value) Then
            desc2Val = wsAcctMap.Range("B" & i).Value
            futureDesc = wsAcctMap.Range("C" & i).Value
            If Not dictDescMap.Exists(desc2Val) Then
                dictDescMap.Add desc2Val, futureDesc
            End If
        End If
    Next i
    
    Call WriteProcessLog(wsProcessLog, "Description mapping loaded. Total mappings: " & dictDescMap.Count)
    
    ' Create final mapping dictionary (Account to FUTURE Description)
    Set dictFinalDescMap = CreateObject("Scripting.Dictionary")
    dictFinalDescMap.CompareMode = vbTextCompare
    
    Dim keyVal As Variant
    For Each keyVal In dictAccountMap.Keys
        desc2 = dictAccountMap(keyVal)
        
        If dictDescMap.Exists(desc2) Then
            dictFinalDescMap.Add keyVal, dictDescMap(desc2)
        Else
            ' If no mapping exists in second map, use the original description
            dictFinalDescMap.Add keyVal, desc2
        End If
    Next keyVal
    
    Call WriteProcessLog(wsProcessLog, "Starting XAV summation with bonus logic...")
    
    lastRowXAV = wsXAV.Cells(wsXAV.Rows.Count, "A").End(xlUp).Row
    
    Set dictResults = CreateObject("Scripting.Dictionary")
    dictResults.CompareMode = vbTextCompare
    
    Set dictProcessed = CreateObject("Scripting.Dictionary")
    dictProcessed.CompareMode = vbTextCompare
    
    ' Process XAV data
    For rowXAV = 2 To lastRowXAV
        voiceNum = wsXAV.Range("N" & rowXAV).Value
        
        ' Skip if already processed this voice number
        If Not dictProcessed.Exists(voiceNum) Then
            dictProcessed.Add voiceNum, True
            
            ' Calculate sum for this voice number
            bonusTotal = 0
            For rowXAV2 = 2 To lastRowXAV
                If wsXAV.Range("N" & rowXAV2).Value = voiceNum Then
                    amountVal = wsXAV.Range("O" & rowXAV2).Value
                    ' Ensure numeric value before adding
                    If IsNumeric(amountVal) Then
                        bonusTotal = bonusTotal + CDbl(amountVal)
                    End If
                End If
            Next rowXAV2
            
            costCenter = wsXAV.Range("E" & rowXAV).Value
            
            accountVal = wsXAV.Range("C" & rowXAV).Value
            
            If dictFinalDescMap.Exists(accountVal) Then
                repDescVal = dictFinalDescMap(accountVal)
            Else
                Call WriteProcessLog(wsProcessLog, "WARNING: Account '" & accountVal & "' not in mapping. VoiceNum=" & voiceNum)
                GoTo SkipVoiceNum
            End If
            
            thisPeriod = wsXAV.Range("A" & rowXAV).Value
            
            ' Check if period exists in period mapping
            If Not dictPeriodMap.Exists(thisPeriod) Then
                Call WriteProcessLog(wsProcessLog, "WARNING: Period '" & thisPeriod & "' not in period mapping. VoiceNum=" & voiceNum)
                GoTo SkipVoiceNum
            End If
            
            key = CStr(costCenter) & "||" & CStr(repDescVal) & "||" & CStr(thisPeriod)
            
            If dictResults.Exists(key) Then
                dictResults(key) = dictResults(key) + bonusTotal
            Else
                dictResults.Add key, bonusTotal
            End If
            
            Call WriteProcessLog(wsProcessLog, "VoiceNum=" & voiceNum & " => CC=" & costCenter & ", Desc=" & repDescVal & ", Period=" & thisPeriod & ", Total=" & bonusTotal)
SkipVoiceNum:
        End If
    Next rowXAV
    
    Call WriteProcessLog(wsProcessLog, "Done summation. Total unique keys: " & dictResults.Count)
    
    Call WriteProcessLog(wsProcessLog, "Populating FUTURE in 5 blocks...")
    
    ' Process each corner cell (CC block)
    For idx = LBound(cornerCells) To UBound(cornerCells)
        cellRef = cornerCells(idx)
        Set rngCorner = wsFuture.Range(cellRef)
        blockCC = rngCorner.Value
        
        If IsEmpty(blockCC) Then
            Call WriteProcessLog(wsProcessLog, "Block corner " & cellRef & " is empty, skipping.")
            GoTo NextCorner
        End If
        
        Call WriteProcessLog(wsProcessLog, "Processing block corner " & cellRef & " => CC=" & blockCC)
        
        ' Map periods to columns
        Set dictPeriodToCol = CreateObject("Scripting.Dictionary")
        dictPeriodToCol.CompareMode = vbTextCompare
        
        startCol = rngCorner.Column + 1
        colPtr = startCol
        
        Do While Not IsEmpty(wsFuture.Cells(rngCorner.Row, colPtr).Value)
            periodVal = wsFuture.Cells(rngCorner.Row, colPtr).Value
            dictPeriodToCol(CStr(periodVal)) = colPtr
            colPtr = colPtr + 1
        Loop
        
        Call WriteProcessLog(wsProcessLog, "Found " & dictPeriodToCol.Count & " period(s) to the right of " & cellRef)
        
        ' Map descriptions to rows
        Set dictDescToRow = CreateObject("Scripting.Dictionary")
        dictDescToRow.CompareMode = vbTextCompare
        
        startRow = rngCorner.Row + 1
        rowPtr = startRow
        
        Do While Not IsEmpty(wsFuture.Cells(rowPtr, rngCorner.Column).Value)
            descVal = wsFuture.Cells(rowPtr, rngCorner.Column).Value
            dictDescToRow(CStr(descVal)) = rowPtr
            rowPtr = rowPtr + 1
        Loop
        
        Call WriteProcessLog(wsProcessLog, "Found " & dictDescToRow.Count & " Report Description(s) below " & cellRef)
        
        ' Populate FUTURE cells from results dictionary
        arrKeys = dictResults.keys
        For k = LBound(arrKeys) To UBound(arrKeys)
            parts = Split(arrKeys(k), "||")
            ccKey = parts(0)
            
            ' Check if this entry belongs to current CC block
            If ccKey = CStr(blockCC) Then
                repDescKey = parts(1)
                xavPeriodKey = parts(2)
                
                ' Get mapped period for FUTURE
                If dictPeriodMap.Exists(xavPeriodKey) Then
                    futurePeriodKey = dictPeriodMap(xavPeriodKey)
                Else
                    Call WriteProcessLog(wsProcessLog, "WARNING: No period mapping for " & xavPeriodKey & " in CC=" & blockCC)
                    GoTo NextKey
                End If
                
                ' Check if we have a matching row and column
                If dictDescToRow.Exists(repDescKey) And dictPeriodToCol.Exists(futurePeriodKey) Then
                    targetRow = dictDescToRow(repDescKey)
                    targetCol = dictPeriodToCol(futurePeriodKey)
                    totalVal = dictResults(arrKeys(k))
                    
                    ' Add to existing value if there's already a value
                    existingVal = wsFuture.Cells(targetRow, targetCol).Value
                    If IsNumeric(existingVal) Then
                        wsFuture.Cells(targetRow, targetCol).Value = CDbl(existingVal) + totalVal
                    Else
                        wsFuture.Cells(targetRow, targetCol).Value = totalVal
                    End If
                    
                    Call WriteProcessLog(wsProcessLog, "Wrote CC=" & blockCC & ", Desc=" & repDescKey & ", Period=" & futurePeriodKey & " => " & totalVal & " at R" & targetRow & "C" & targetCol)
                End If
NextKey:
            End If
        Next k
NextCorner:
    Next idx
    
    ' Calculate totals if needed
    Call WriteProcessLog(wsProcessLog, "Calculating row and column totals...")
    For idx = LBound(cornerCells) To UBound(cornerCells)
        cellRef = cornerCells(idx)
        Set rngCorner = wsFuture.Range(cellRef)
        blockCC = rngCorner.Value
        
        If IsEmpty(blockCC) Then
            GoTo NextCornerTotal
        End If
        
        startRow = rngCorner.Row + 1
        rowPtr = startRow
        startCol = rngCorner.Column + 1
        colPtr = startCol
        
        ' Find the boundaries
        lastRow = startRow
        Do While Not IsEmpty(wsFuture.Cells(lastRow, rngCorner.Column).Value)
            lastRow = lastRow + 1
        Loop
        lastRow = lastRow - 1
        
        lastCol = startCol
        Do While Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol).Value)
            lastCol = lastCol + 1
        Loop
        lastCol = lastCol - 1
        
        ' Add row totals
        For rowPtr = startRow To lastRow
            rowTotal = 0
            
            For colPtr = startCol To lastCol
                cellVal = wsFuture.Cells(rowPtr, colPtr).Value
                
                If IsNumeric(cellVal) Then
                    rowTotal = rowTotal + CDbl(cellVal)
                End If
            Next colPtr
            
            ' Write row total if there's a total column
            If Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol + 1).Value) Then
                wsFuture.Cells(rowPtr, lastCol + 1).Value = rowTotal
            End If
        Next rowPtr
        
        ' Add column totals
        For colPtr = startCol To lastCol
            colTotal = 0
            
            For rowPtr = startRow To lastRow
                cellVal = wsFuture.Cells(rowPtr, colPtr).Value
                
                If IsNumeric(cellVal) Then
                    colTotal = colTotal + CDbl(cellVal)
                End If
            Next rowPtr
            
            ' Write column total if there's a total row
            If Not IsEmpty(wsFuture.Cells(lastRow + 1, rngCorner.Column).Value) Then
                wsFuture.Cells(lastRow + 1, colPtr).Value = colTotal
            End If
        Next colPtr
        
        ' Grand total if both total row and column exist
        If Not IsEmpty(wsFuture.Cells(lastRow + 1, rngCorner.Column).Value) And _
           Not IsEmpty(wsFuture.Cells(rngCorner.Row, lastCol + 1).Value) Then
            grandTotal = 0
            
            For rowPtr = startRow To lastRow
                For colPtr = startCol To lastCol
                    cellVal = wsFuture.Cells(rowPtr, colPtr).Value
                    
                    If IsNumeric(cellVal) Then
                        grandTotal = grandTotal + CDbl(cellVal)
                    End If
                Next colPtr
            Next rowPtr
            
            wsFuture.Cells(lastRow + 1, lastCol + 1).Value = grandTotal
        End If
        
NextCornerTotal:
    Next idx
    
    Call WriteProcessLog(wsProcessLog, SubName & ": Completed successfully!")
    MsgBox "FUTURE sheet updated for all 5 CC blocks! See 'ProcessLog' for details.", vbInformation
End Sub
