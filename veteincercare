let
    // Step 1: Prepare SView data
    SV_Original = SViewData_Comp,
    SVRenamed = Table.RenameColumns(SV_Original, {{"Parent", "SView Parent"}}),
    SVSelected = Table.SelectColumns(
        SVRenamed,
        {"KEY", "Hierarchy Name", "Value", "SView Parent", "SView Path"}
    ),
    
    // Step 2: Prepare XRP data
    XRPOriginal = XRPData_Comp,
    XRPRenamed = Table.RenameColumns(
        XRPOriginal,
        {{"Parent", "XRP Parent"}},
        MissingField.Ignore
    ),
    
    XRPSelected = Table.SelectColumns(
        XRPRenamed,
        {"KEY", "XRP Parent", "XRP Path"}
    ),
    
    // Step 3: Join the tables
    FullJoin = Table.NestedJoin(
        SVSelected, {"KEY"}, XRPSelected, {"KEY"}, "XRPData", JoinKind.FullOuter
    ),
    
    // Step 4: Expand the joined table
    Expanded = Table.ExpandTableColumn(
        FullJoin,
        "XRPData", 
        {"XRP Parent", "XRP Path"}, 
        {"XRP Parent", "XRP Path"}
    ),
    
    // Step 5: Extract Hierarchy Name and Value from XRP KEY when SView is missing
    // First, add temporary columns for the extracted values
    WithExtractedKey = Table.AddColumn(
        Expanded,
        "Extracted Key",
        each if [Hierarchy Name] = null and [KEY] <> null then 
            let
                keyParts = Text.Split([KEY], "/"),
                finalKey = keyParts{List.Count(keyParts)-1}
            in
                finalKey
        else null
    ),
    
    // Step 6: Create new columns with proper fallback to extracted key
    WithFixedHierarchy = Table.AddColumn(
        WithExtractedKey,
        "Fixed Hierarchy Name",
        each if [Hierarchy Name] = null then [Extracted Key] else [Hierarchy Name]
    ),
    
    WithFixedValue = Table.AddColumn(
        WithFixedHierarchy,
        "Fixed Value",
        each if [Value] = null then [Extracted Key] else [Value]
    ),
    
    // Step 7: Remove original columns and rename the fixed ones
    RemovedOriginals = Table.RemoveColumns(
        WithFixedValue,
        {"Hierarchy Name", "Value", "Extracted Key"}
    ),
    
    RenamedFixed = Table.RenameColumns(
        RemovedOriginals,
        {
            {"Fixed Hierarchy Name", "Hierarchy Name"},
            {"Fixed Value", "Value"}
        }
    ),
    
    // Step 8: Add dimension from Hierarchy_Matrix based on the Hierarchy Name
    WithDimension = Table.AddColumn(
        RenamedFixed,
        "Dimension",
        each 
            let
                matchingRows = Table.SelectRows(Hierarchy_Matrix, (h) => h[Hierarchy Name] = [Hierarchy Name]),
                dimensionValue = if Table.RowCount(matchingRows) > 0 then matchingRows{0}[Dimension] else null
            in
                dimensionValue
    ),
    
    // Step 9: Add status column
    WithStatus = Table.AddColumn(
        WithDimension,
        "Status",
        each
            let
                svP = if [SView Parent] = null then "" else [SView Parent],
                xrpP = if [XRP Parent] = null then "" else [XRP Parent]
            in
                if svP = "" and xrpP = "" then "Parent match"
                else if svP = "" and xrpP <> "" then "Missing in SView"
                else if svP <> "" and xrpP = "" then "Missing in XRP"
                else if svP <> xrpP then "Parent mismatch"
                else "Parent match"
    ),
    
    // Step 10: Select final columns
    FinalColumns = Table.SelectColumns(
        WithStatus,
        {
            "KEY",
            "Hierarchy Name",
            "Value",
            "SView Parent", 
            "XRP Parent",
            "Status",
            "SView Path",
            "XRP Path",
            "Dimension"
        }
    ),
    
    // Step 11: Remove parent matches if needed
    RemoveMatches = Table.SelectRows(FinalColumns, each [Status] <> "Parent match")
in
    RemoveMatches
